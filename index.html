<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Auf den Dächern des Süd</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        :root {
            --header-height: 72px;
        }

        body {
            font-family: 'Inter', sans-serif;
            touch-action: none;
            overflow: hidden;
            background-color: #f1f5f9;
            /* Nutzt die dynamische Viewport-Höhe gegen iPad-Tab-Überdeckungen */
            height: 100dvh;
        }

        #canvas-container {
            background-color: #cbd5e1;
            position: relative;
            overflow: hidden;
            flex: 1;
            touch-action: none;
        }

        #canvas-viewport {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            background-repeat: no-repeat;
            background-size: 100% 100%;
        }

        .rect {
            position: absolute;
            border-width: 2px;
            pointer-events: none;
            will-change: left, top, width, height;
        }

        .handle {
            position: absolute;
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 100;
            border: 2px solid white;
            cursor: pointer;
            pointer-events: auto;
            margin-left: -22px;
            margin-top: -22px;
        }

        .area-label {
            position: absolute;
            padding: 4px 10px;
            font-size: 14px;
            font-weight: 900;
            border-radius: 6px;
            white-space: nowrap;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 20;
            pointer-events: none;
            transform-origin: left bottom;
        }

        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* Bilanz-Sektion liegt fixiert über der Liste */
        #balance-section {
            box-shadow: 0 -10px 30px rgba(0,0,0,0.4);
            z-index: 60;
        }
    </style>
</head>
<body class="flex flex-col text-slate-900">

    <!-- Header mit festem Platzbedarf -->
    <header class="bg-slate-900 text-white p-4 shadow-xl flex justify-between items-center z-[70] shrink-0 h-[var(--header-height)]">
        <div class="flex items-center gap-4">
            <div class="bg-blue-600 p-2 rounded-xl shadow-lg">
                <i data-lucide="calculator" class="w-5 h-5 text-white"></i>
            </div>
            <h1 class="text-xs md:text-sm font-black tracking-tight uppercase leading-none">Auf den Dächern des Süd</h1>
        </div>

        <div class="flex items-center gap-2 md:gap-3">
            <div class="flex bg-slate-800 rounded-xl p-1 border border-slate-700">
                <button id="btn-plus" class="px-3 md:px-6 py-2 rounded-lg flex items-center gap-2 text-[10px] md:text-xs font-bold transition-all bg-emerald-500 text-white shadow-lg">
                    <i data-lucide="plus" class="w-3 h-3 md:w-4 md:h-4"></i> Addition (+)
                </button>
                <button id="btn-minus" class="px-3 md:px-6 py-2 rounded-lg flex items-center gap-2 text-[10px] md:text-xs font-bold transition-all text-slate-500 hover:text-slate-300">
                    <i data-lucide="minus" class="w-3 h-3 md:w-4 md:h-4"></i> Abzug (−)
                </button>
            </div>
            
            <button id="btn-reset" class="p-2.5 bg-slate-800 text-slate-400 hover:text-rose-400 hover:bg-slate-700 rounded-xl transition-all border border-slate-700">
                <i data-lucide="refresh-ccw" class="w-5 h-5"></i>
            </button>
        </div>
    </header>

    <div class="flex flex-1 flex-col md:flex-row overflow-hidden relative">
        <!-- Canvas Bereich -->
        <main id="canvas-container" class="order-2 md:order-1 flex-1">
            <div id="canvas-viewport">
                <div id="canvas">
                    <div id="drawing-preview" class="absolute border-2 pointer-events-none hidden z-50"></div>
                </div>
            </div>
        </main>

        <!-- Sidebar -->
        <aside class="order-1 md:order-2 w-full md:w-80 bg-white border-l border-slate-200 flex flex-col shadow-2xl shrink-0 z-50 h-[35dvh] md:h-full overflow-hidden">
            <!-- Scrollbarer Teil: Teilflächen -->
            <div id="rect-list" class="flex-1 overflow-y-auto p-4 space-y-2 bg-slate-50/10 text-center scrollbar-hide pb-10">
                <h3 class="text-[10px] font-black text-slate-300 uppercase tracking-[0.2em] mb-4">Teilflächen</h3>
                <div id="list-content"></div>
                <div class="h-20"></div> <!-- Spacer damit nichts verdeckt wird -->
            </div>

            <!-- Fixierter Teil: Bilanz -->
            <div id="balance-section" class="bg-slate-900 p-5 md:p-6 rounded-t-[2.5rem] md:rounded-t-[3rem] space-y-4 shrink-0">
                <div class="grid grid-cols-2 gap-3 text-left">
                    <div class="bg-emerald-500/10 border border-emerald-500/20 p-3 rounded-2xl">
                        <p class="text-[8px] font-black text-emerald-500 uppercase tracking-widest mb-1 leading-none">Addition (+)</p>
                        <p id="sum-plus" class="text-base md:text-lg font-black text-emerald-400 font-mono">+0.0</p>
                    </div>
                    <div class="bg-rose-500/10 border border-rose-500/20 p-3 rounded-2xl">
                        <p class="text-[8px] font-black text-rose-500 uppercase tracking-widest mb-1 leading-none">Abzug (−)</p>
                        <p id="sum-minus" class="text-base md:text-lg font-black text-rose-400 font-mono">−0.0</p>
                    </div>
                </div>

                <div class="pt-2 border-t border-white/5 text-center text-white">
                    <p class="text-[9px] font-black text-blue-400 uppercase tracking-[0.4em] mb-1">Gesamtfläche</p>
                    <div class="flex justify-center items-baseline gap-2 mb-2">
                        <span id="total-area" class="text-4xl md:text-5xl font-black text-white font-mono tracking-tighter drop-shadow-lg">0.00</span>
                        <span class="text-xs font-bold text-slate-500 uppercase">m²</span>
                    </div>
                </div>

                <div class="bg-white/5 rounded-2xl p-4 border border-white/5">
                    <p class="text-[8px] text-slate-500 font-bold mb-1 uppercase tracking-widest flex items-center gap-2">
                        <span class="w-1.5 h-1.5 bg-blue-500 rounded-full animate-pulse shadow-[0_0_8px_rgba(59,130,246,0.6)]"></span>
                        Rechenweg
                    </p>
                    <div id="calculation-path" class="font-mono text-[10px] text-blue-200/60 overflow-x-auto whitespace-nowrap scrollbar-hide text-left italic">
                        A = 0.00
                    </div>
                </div>
            </div>
        </aside>
    </div>

    <script>
        const CONFIG = {
            backgroundImage: "https://i.postimg.cc/qBZLKnWs/Bildschirmfoto-2026-02-22-um-17-09-09.png",
            REAL_IMAGE_WIDTH_METERS: 133,
            STORAGE_KEY: 'school_area_geo_final_v1'
        };

        // State
        let rects = JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEY)) || [];
        let selectedId = null;
        let isPositiveMode = true;
        let metersPerPixel = 0;
        let imgDim = { w: 0, h: 0 };

        // Viewport
        let zoom = 1;
        let panX = 0;
        let panY = 0;

        // Interaction
        let drawingRect = null;
        let isDragging = false;
        let isResizing = false;
        let dragStartCanvasPos = { x: 0, y: 0 };
        let initialRectState = null;
        let activeTouchMode = 'none';
        let lastTouchDist = 0;
        let lastTouchMid = { x: 0, y: 0 };

        const canvas = document.getElementById('canvas');
        const viewport = document.getElementById('canvas-viewport');
        const container = document.getElementById('canvas-container');
        const drawingPreview = document.getElementById('drawing-preview');
        const listContent = document.getElementById('list-content');

        function init() {
            const img = new Image();
            img.src = CONFIG.backgroundImage;
            img.onload = () => {
                imgDim = { w: img.naturalWidth, h: img.naturalHeight };
                metersPerPixel = CONFIG.REAL_IMAGE_WIDTH_METERS / imgDim.w;
                
                canvas.style.backgroundImage = `url("${CONFIG.backgroundImage}")`;
                canvas.style.width = imgDim.w + 'px';
                canvas.style.height = imgDim.h + 'px';

                // Initial zentrieren
                const cRect = container.getBoundingClientRect();
                const scale = Math.min(cRect.width / imgDim.w, cRect.height / imgDim.h) * 0.85;
                zoom = scale;
                panX = (cRect.width - imgDim.w * zoom) / 2;
                panY = (cRect.height - imgDim.h * zoom) / 2;
                
                updateModeUI();
                render(true);
            };
            setupEvents();
            lucide.createIcons();
        }

        function getCanvasPos(clientX, clientY) {
            const cRect = container.getBoundingClientRect();
            return {
                x: (clientX - cRect.left - panX) / zoom,
                y: (clientY - cRect.top - panY) / zoom
            };
        }

        function setupEvents() {
            document.getElementById('btn-plus').onclick = (e) => {
                e.stopPropagation();
                setMode(true);
            };
            document.getElementById('btn-minus').onclick = (e) => {
                e.stopPropagation();
                setMode(false);
            };
            
            // RESET FUNKTION REPARIERT
            document.getElementById('btn-reset').onclick = (e) => {
                e.preventDefault();
                if(confirm("Möchtest du wirklich alle eingezeichneten Flächen löschen?")) {
                    rects = [];
                    selectedId = null;
                    saveAndRender();
                }
            };

            const onStart = (e) => {
                const isTouch = e.type.startsWith('touch');
                if (isTouch && e.touches.length === 2) {
                    activeTouchMode = 'navigate';
                    lastTouchDist = getTouchDist(e);
                    lastTouchMid = getTouchMidpoint(e);
                    return;
                }
                
                const clientX = isTouch ? e.touches[0].clientX : e.clientX;
                const clientY = isTouch ? e.touches[0].clientY : e.clientY;
                const pos = getCanvasPos(clientX, clientY);
                activeTouchMode = 'draw';

                if (selectedId) {
                    const r = rects.find(x => x.id === selectedId);
                    if (r) {
                        const hRadius = 25 / zoom; 
                        // Müll (Top Right)
                        if (Math.abs(pos.x - (r.x + r.width)) < hRadius && Math.abs(pos.y - r.y) < hRadius) {
                            rects = rects.filter(x => x.id !== selectedId); selectedId = null; saveAndRender(); return;
                        }
                        // Skalieren (Bottom Right)
                        if (Math.abs(pos.x - (r.x + r.width)) < hRadius && Math.abs(pos.y - (r.y + r.height)) < hRadius) {
                            isResizing = true; dragStartCanvasPos = pos; initialRectState = JSON.parse(JSON.stringify(r)); return;
                        }
                        // Verschieben (Top Left)
                        if (Math.abs(pos.x - r.x) < hRadius && Math.abs(pos.y - r.y) < hRadius) {
                            isDragging = true; dragStartCanvasPos = pos; initialRectState = JSON.parse(JSON.stringify(r)); return;
                        }
                    }
                }
                drawingRect = { x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y, startPos: pos };
            };

            const onMove = (e) => {
                const isTouch = e.type.startsWith('touch');
                if (activeTouchMode === 'navigate' && isTouch && e.touches.length === 2) {
                    const dist = getTouchDist(e);
                    const mid = getTouchMidpoint(e);
                    const scaleChange = dist / lastTouchDist;
                    const newZoom = Math.max(0.1, Math.min(10, zoom * scaleChange));
                    const cRect = container.getBoundingClientRect();
                    
                    panX = mid.x - cRect.left - (mid.x - cRect.left - panX) * (newZoom / zoom);
                    panY = mid.y - cRect.top - (mid.y - cRect.top - panY) * (newZoom / zoom);
                    panX += (mid.x - lastTouchMid.x);
                    panY += (mid.y - lastTouchMid.y);
                    
                    zoom = newZoom;
                    lastTouchDist = dist;
                    lastTouchMid = mid;
                    requestAnimationFrame(() => render(false));
                    return;
                }

                if (activeTouchMode !== 'draw') return;
                const clientX = isTouch ? e.touches[0].clientX : e.clientX;
                const clientY = isTouch ? e.touches[0].clientY : e.clientY;
                const pos = getCanvasPos(clientX, clientY);
                
                if (isResizing && selectedId) {
                    const dx = pos.x - dragStartCanvasPos.x; 
                    const dy = pos.y - dragStartCanvasPos.y;
                    rects = rects.map(r => r.id === selectedId ? { 
                        ...r, width: Math.max(5, initialRectState.width + dx), height: Math.max(5, initialRectState.height + dy) 
                    } : r);
                    requestAnimationFrame(() => render(false));
                } else if (isDragging && selectedId) {
                    const dx = pos.x - dragStartCanvasPos.x; 
                    const dy = pos.y - dragStartCanvasPos.y;
                    rects = rects.map(r => r.id === selectedId ? { 
                        ...r, x: initialRectState.x + dx, y: initialRectState.y + dy 
                    } : r);
                    requestAnimationFrame(() => render(false));
                } else if (drawingRect) {
                    drawingRect.x2 = pos.x; drawingRect.y2 = pos.y;
                    updatePreview();
                }
            };

            const onEnd = (e) => {
                if (activeTouchMode === 'draw' && drawingRect) {
                    const w = Math.abs(drawingRect.x2 - drawingRect.x1);
                    const h = Math.abs(drawingRect.y2 - drawingRect.y1);
                    if (w > 10 && h > 10) {
                        const nr = { id: Date.now(), x: Math.min(drawingRect.x1, drawingRect.x2), y: Math.min(drawingRect.y1, drawingRect.y2), width: w, height: h, isPositive: isPositiveMode };
                        rects.push(nr); selectedId = nr.id; saveAndRender();
                    } else if (!isDragging && !isResizing) {
                        const hit = [...rects].reverse().find(r => 
                            drawingRect.startPos.x >= r.x && drawingRect.startPos.x <= r.x + r.width && 
                            drawingRect.startPos.y >= r.y && drawingRect.startPos.y <= r.y + r.height
                        );
                        selectedId = hit ? hit.id : null; render(true);
                    }
                }
                drawingRect = null; isDragging = false; isResizing = false; activeTouchMode = 'none';
                drawingPreview.classList.add('hidden');
                if (selectedId) render(true); 
            };

            container.onmousedown = onStart;
            window.onmousemove = onMove;
            window.onmouseup = onEnd;
            container.ontouchstart = (e) => { if(e.touches.length === 1) e.preventDefault(); onStart(e); };
            window.ontouchmove = (e) => { if(e.touches.length === 1) e.preventDefault(); onMove(e); };
            window.ontouchend = onEnd;

            container.onwheel = (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(0.1, Math.min(10, zoom * delta));
                const cRect = container.getBoundingClientRect();
                panX = e.clientX - cRect.left - (e.clientX - cRect.left - panX) * (newZoom / zoom);
                panY = e.clientY - cRect.top - (e.clientY - cRect.top - panY) * (newZoom / zoom);
                zoom = newZoom;
                render(false);
            };
        }

        function getTouchDist(e) { return Math.sqrt(Math.pow(e.touches[0].clientX - e.touches[1].clientX, 2) + Math.pow(e.touches[0].clientY - e.touches[1].clientY, 2)); }
        function getTouchMidpoint(e) { return { x: (e.touches[0].clientX + e.touches[1].clientX) / 2, y: (e.touches[0].clientY + e.touches[1].clientY) / 2 }; }

        function setMode(pos) {
            isPositiveMode = pos;
            updateModeUI();
        }

        function updateModeUI() {
            document.getElementById('btn-plus').className = isPositiveMode ? 'px-3 md:px-6 py-2 rounded-lg flex items-center gap-2 text-[10px] md:text-xs font-bold transition-all bg-emerald-500 text-white shadow-lg scale-105' : 'px-3 md:px-6 py-2 rounded-lg flex items-center gap-2 text-[10px] md:text-xs font-bold transition-all text-slate-500 hover:text-slate-300';
            document.getElementById('btn-minus').className = !isPositiveMode ? 'px-3 md:px-6 py-2 rounded-lg flex items-center gap-2 text-[10px] md:text-xs font-bold transition-all bg-rose-500 text-white shadow-lg scale-105' : 'px-3 md:px-6 py-2 rounded-lg flex items-center gap-2 text-[10px] md:text-xs font-bold transition-all text-slate-500 hover:text-slate-300';
        }

        function updatePreview() {
            if (!drawingRect) return;
            drawingPreview.classList.remove('hidden');
            Object.assign(drawingPreview.style, {
                left: Math.min(drawingRect.x1, drawingRect.x2) + 'px',
                top: Math.min(drawingRect.y1, drawingRect.y2) + 'px',
                width: Math.abs(drawingRect.x2 - drawingRect.x1) + 'px',
                height: Math.abs(drawingRect.y2 - drawingRect.y1) + 'px'
            });
            drawingPreview.className = `absolute border-2 pointer-events-none z-50 ${isPositiveMode ? 'bg-emerald-500/15 border-emerald-400 shadow-xl' : 'bg-rose-500/15 border-rose-400 border-dashed shadow-xl'}`;
        }

        function saveAndRender() { 
            localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(rects)); 
            render(true); 
        }

        function render(rebuild = false) {
            viewport.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            
            if (rebuild) {
                const elements = canvas.querySelectorAll('.rect, .handle');
                elements.forEach(el => el.remove());
            }

            let sumP = 0, sumN = 0;
            const uiScale = 1 / zoom;

            rects.forEach(r => {
                const area = (r.width * metersPerPixel) * (r.height * metersPerPixel);
                if (r.isPositive) sumP += area; else sumN += area;

                let div = rebuild ? null : canvas.querySelector(`[data-id="${r.id}"]`);
                if (!div) {
                    div = document.createElement('div');
                    div.setAttribute('data-id', r.id);
                    canvas.appendChild(div);
                }

                div.className = `rect ${r.isPositive ? 'border-emerald-600 bg-emerald-500/30' : 'border-rose-600 bg-rose-500/30 border-dashed'} ${selectedId === r.id ? 'ring-2 ring-blue-400 ring-offset-2 z-30 shadow-2xl' : 'z-10'}`;
                Object.assign(div.style, { left: r.x + 'px', top: r.y + 'px', width: r.width + 'px', height: r.height + 'px' });

                let label = div.querySelector('.area-label');
                if (!label) {
                    label = document.createElement('div');
                    div.appendChild(label);
                }
                label.className = `area-label ${r.isPositive ? 'bg-emerald-600 border-emerald-700' : 'bg-rose-600 border-rose-700'} text-white border`;
                label.style.transform = `scale(${uiScale}) translateY(-25px)`;
                label.innerText = `${r.isPositive ? '+' : '−'} ${area.toFixed(1)} m²`;

                if (selectedId === r.id && rebuild) {
                    div.appendChild(createHandle('move', 'bg-blue-500', 0, 0, uiScale));
                    div.appendChild(createHandle('trash-2', 'bg-rose-500', r.width, 0, uiScale));
                    div.appendChild(createHandle('maximize-2', 'bg-blue-500', r.width, r.height, uiScale));
                    lucide.createIcons();
                }
            });

            updateSidebar(sumP, sumN);
        }

        function createHandle(icon, color, x, y, hScale) {
            const h = document.createElement('div');
            h.className = `handle ${color}`;
            Object.assign(h.style, { left: x + 'px', top: y + 'px', transform: `scale(${hScale})` });
            h.innerHTML = `<i data-lucide="${icon}" style="width: 22px; height: 22px"></i>`;
            return h;
        }

        function updateSidebar(sumP, sumN) {
            document.getElementById('sum-plus').innerText = `+${sumP.toFixed(1)}`;
            document.getElementById('sum-minus').innerText = `−${sumN.toFixed(1)}`;
            document.getElementById('total-area').innerText = (sumP - sumN).toFixed(2);
            
            // Verhindert Flackern während der Bewegung
            if (drawingRect || isDragging || isResizing) return; 

            listContent.innerHTML = '';
            rects.forEach((r, i) => {
                const area = (r.width * metersPerPixel) * (r.height * metersPerPixel);
                const btn = document.createElement('button');
                btn.className = `w-full flex items-center justify-between p-3 rounded-2xl border transition-all text-[11px] mb-2 ${selectedId === r.id ? 'bg-blue-50 border-blue-200 shadow-md ring-1 ring-blue-100' : 'bg-white border-slate-100 hover:border-slate-300 shadow-sm'}`;
                btn.onclick = () => { selectedId = r.id; render(true); };
                btn.innerHTML = `<div class="flex items-center gap-3 text-left"><div class="w-6 h-6 rounded-lg flex items-center justify-center text-[10px] text-white font-black shrink-0 ${r.isPositive ? 'bg-emerald-500' : 'bg-rose-500'}">${i + 1}</div><div class="flex flex-col"><span class="text-[9px] text-slate-400 font-bold uppercase leading-none mb-1 text-left">${r.isPositive ? 'Addition' : 'Abzug'}</span><span class="font-mono font-bold text-slate-700 text-left">${r.isPositive ? '+' : '−'} ${area.toFixed(1)} m²</span></div></div>`;
                listContent.appendChild(btn);
            });

            const path = document.getElementById('calculation-path');
            if (rects.length > 0) {
                path.innerHTML = 'A = ' + rects.map((r, i) => `<span class="${r.isPositive ? 'text-emerald-400/80' : 'text-rose-400/80'}">${r.isPositive ? (i === 0 ? '' : ' + ') : ' − '}${(r.width * r.height * metersPerPixel * metersPerPixel).toFixed(1)}</span>`).join('');
            } else path.innerText = 'A = 0.00';
        }

        init();
    </script>
</body>
</html>
